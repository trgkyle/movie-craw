# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AddMovieLinksToMovieServerInput {
  """The id of the record."""
  id: Int!

  """The ids of the relations."""
  relationIds: [Int!]!
}

input AddMovieServersToMoviePartInput {
  """The id of the record."""
  id: Int!

  """The ids of the relations."""
  relationIds: [Int!]!
}

type Category {
  categoryLinks(
    """Specify to filter the records returned."""
    filter: CategoryLinkFilter = {}

    """Specify to sort results."""
    sorting: [CategoryLinkSort!] = []
  ): [CategoryLink!]!
  id: Int!
  movies(
    """Specify to filter the records returned."""
    filter: MovieFilter = {}

    """Specify to sort results."""
    sorting: [MovieSort!] = []
  ): [Movie!]!
  name: String!
  type: String!
}

type CategoryAggregateGroupBy {
  id: Int
  name: String
  type: String
}

type CategoryAvgAggregate {
  id: Float
}

type CategoryConnection {
  """Array of edges."""
  edges: [CategoryEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type CategoryCountAggregate {
  id: Int
  name: Int
  type: Int
}

type CategoryEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Category"""
  node: Category!
}

input CategoryFilter {
  and: [CategoryFilter!]
  categoryLinks: CategoryFilterCategoryLinkFilter
  id: IntFieldComparison
  movies: CategoryFilterMovieFilter
  name: StringFieldComparison
  or: [CategoryFilter!]
  type: StringFieldComparison
}

input CategoryFilterCategoryLinkFilter {
  and: [CategoryFilterCategoryLinkFilter!]
  id: StringFieldComparison
  link: StringFieldComparison
  or: [CategoryFilterCategoryLinkFilter!]
  provider: StringFieldComparison
}

input CategoryFilterMovieFilter {
  and: [CategoryFilterMovieFilter!]
  id: IntFieldComparison
  name: StringFieldComparison
  or: [CategoryFilterMovieFilter!]
}

type CategoryLink {
  id: String!
  link: String!
  provider: String!
}

type CategoryLinkAggregateGroupBy {
  id: String
  link: String
  provider: String
}

type CategoryLinkAvgAggregate {
  id: Float
}

type CategoryLinkCountAggregate {
  id: Int
  link: Int
  provider: Int
}

type CategoryLinkEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the CategoryLink"""
  node: CategoryLink!
}

input CategoryLinkFilter {
  and: [CategoryLinkFilter!]
  id: StringFieldComparison
  link: StringFieldComparison
  or: [CategoryLinkFilter!]
  provider: StringFieldComparison
}

type CategoryLinkMaxAggregate {
  id: String
  link: String
  provider: String
}

type CategoryLinkMinAggregate {
  id: String
  link: String
  provider: String
}

input CategoryLinkSort {
  direction: SortDirection!
  field: CategoryLinkSortFields!
  nulls: SortNulls
}

enum CategoryLinkSortFields {
  id
  link
  provider
}

type CategoryLinkSumAggregate {
  id: Float
}

type CategoryMaxAggregate {
  id: Int
  name: String
  type: String
}

type CategoryMinAggregate {
  id: Int
  name: String
  type: String
}

input CategorySort {
  direction: SortDirection!
  field: CategorySortFields!
  nulls: SortNulls
}

enum CategorySortFields {
  id
  name
  type
}

type CategorySumAggregate {
  id: Float
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

input CreateMovieSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MovieSubscriptionFilter!
}

input CursorPaging {
  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteOneMovieSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MovieSubscriptionFilter!
}

input IntFieldComparison {
  between: IntFieldComparisonBetween
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  is: Boolean
  isNot: Boolean
  lt: Int
  lte: Int
  neq: Int
  notBetween: IntFieldComparisonBetween
  notIn: [Int!]
}

input IntFieldComparisonBetween {
  lower: Int!
  upper: Int!
}

type JobData {
  numberAccount: Float
  post_link: String
  status: Boolean!
}

type JobsDeleteResult {
  status: Boolean!
}

type JobsListResult {
  id: String!
  job_data: JobData!
  job_type: String!
  status: Boolean!
}

type JobsRegisterResult {
  status: Boolean!
}

type Movie {
  categories(
    """Specify to filter the records returned."""
    filter: CategoryFilter = {}

    """Specify to sort results."""
    sorting: [CategorySort!] = []
  ): [Category!]!
  description: String!
  id: Int!
  movieParts(
    """Specify to filter the records returned."""
    filter: MoviePartFilter = {}

    """Specify to sort results."""
    sorting: [MoviePartSort!] = []
  ): [MoviePart!]!
  name: String!
  poster: String!
}

type MovieAggregateGroupBy {
  id: Int
  name: String
}

type MovieAvgAggregate {
  id: Float
}

type MovieConnection {
  """Array of edges."""
  edges: [MovieEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type MovieCountAggregate {
  id: Int
  name: Int
}

type MovieDeleteResponse {
  description: String
  id: Int
  name: String
  poster: String
}

type MovieEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Movie"""
  node: Movie!
}

input MovieFilter {
  and: [MovieFilter!]
  categories: MovieFilterCategoryFilter
  id: IntFieldComparison
  movieParts: MovieFilterMoviePartFilter
  name: StringFieldComparison
  or: [MovieFilter!]
}

input MovieFilterCategoryFilter {
  and: [MovieFilterCategoryFilter!]
  id: IntFieldComparison
  name: StringFieldComparison
  or: [MovieFilterCategoryFilter!]
  type: StringFieldComparison
}

input MovieFilterMoviePartFilter {
  and: [MovieFilterMoviePartFilter!]
  id: IntFieldComparison
  or: [MovieFilterMoviePartFilter!]
  part: StringFieldComparison
  type: StringFieldComparison
}

type MovieLink {
  id: Int!
  name: String!
  videoLink: String!
}

type MovieLinkAggregateGroupBy {
  id: Int
  name: String
}

type MovieLinkAvgAggregate {
  id: Float
}

type MovieLinkCountAggregate {
  id: Int
  name: Int
}

type MovieLinkEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the MovieLink"""
  node: MovieLink!
}

input MovieLinkFilter {
  and: [MovieLinkFilter!]
  id: IntFieldComparison
  name: StringFieldComparison
  or: [MovieLinkFilter!]
}

type MovieLinkMaxAggregate {
  id: Int
  name: String
}

type MovieLinkMinAggregate {
  id: Int
  name: String
}

input MovieLinkSort {
  direction: SortDirection!
  field: MovieLinkSortFields!
  nulls: SortNulls
}

enum MovieLinkSortFields {
  id
  name
}

type MovieLinkSumAggregate {
  id: Float
}

type MovieMaxAggregate {
  id: Int
  name: String
}

type MovieMinAggregate {
  id: Int
  name: String
}

type MoviePart {
  id: Int!
  movieServers(
    """Specify to filter the records returned."""
    filter: MovieServerFilter = {}

    """Specify to sort results."""
    sorting: [MovieServerSort!] = []
  ): [MovieServer!]!
  part: String!
  type: String!
}

type MoviePartAggregateGroupBy {
  id: Int
  part: String
  type: String
}

type MoviePartAvgAggregate {
  id: Float
}

type MoviePartCountAggregate {
  id: Int
  part: Int
  type: Int
}

type MoviePartEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the MoviePart"""
  node: MoviePart!
}

input MoviePartFilter {
  and: [MoviePartFilter!]
  id: IntFieldComparison
  movieServers: MoviePartFilterMovieServerFilter
  or: [MoviePartFilter!]
  part: StringFieldComparison
  type: StringFieldComparison
}

input MoviePartFilterMovieServerFilter {
  and: [MoviePartFilterMovieServerFilter!]
  id: IntFieldComparison
  or: [MoviePartFilterMovieServerFilter!]
  provider: StringFieldComparison
}

type MoviePartMaxAggregate {
  id: Int
  part: String
  type: String
}

type MoviePartMinAggregate {
  id: Int
  part: String
  type: String
}

input MoviePartSort {
  direction: SortDirection!
  field: MoviePartSortFields!
  nulls: SortNulls
}

enum MoviePartSortFields {
  id
  part
  type
}

type MoviePartSumAggregate {
  id: Float
}

type MovieServer {
  id: Int!
  movieLinks(
    """Specify to filter the records returned."""
    filter: MovieLinkFilter = {}

    """Specify to sort results."""
    sorting: [MovieLinkSort!] = []
  ): [MovieLink!]!
  provider: String!
}

type MovieServerAggregateGroupBy {
  id: Int
  provider: String
}

type MovieServerAvgAggregate {
  id: Float
}

type MovieServerCountAggregate {
  id: Int
  provider: Int
}

type MovieServerEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the MovieServer"""
  node: MovieServer!
}

input MovieServerFilter {
  and: [MovieServerFilter!]
  id: IntFieldComparison
  movieLinks: MovieServerFilterMovieLinkFilter
  or: [MovieServerFilter!]
  provider: StringFieldComparison
}

input MovieServerFilterMovieLinkFilter {
  and: [MovieServerFilterMovieLinkFilter!]
  id: IntFieldComparison
  name: StringFieldComparison
  or: [MovieServerFilterMovieLinkFilter!]
}

type MovieServerMaxAggregate {
  id: Int
  provider: String
}

type MovieServerMinAggregate {
  id: Int
  provider: String
}

input MovieServerSort {
  direction: SortDirection!
  field: MovieServerSortFields!
  nulls: SortNulls
}

enum MovieServerSortFields {
  id
  provider
}

type MovieServerSumAggregate {
  id: Float
}

input MovieSort {
  direction: SortDirection!
  field: MovieSortFields!
  nulls: SortNulls
}

enum MovieSortFields {
  id
  name
}

input MovieSubscriptionFilter {
  and: [MovieSubscriptionFilter!]
  id: IntFieldComparison
  name: StringFieldComparison
  or: [MovieSubscriptionFilter!]
}

type MovieSumAggregate {
  id: Float
}

type Mutation {
  addJob(name: String!): JobsRegisterResult!
  addMovieLinksToMovieServer(input: AddMovieLinksToMovieServerInput!): MovieServer!
  addMovieServersToMoviePart(input: AddMovieServersToMoviePartInput!): MoviePart!
  deleteJob(id: [String!]!): JobsDeleteResult!
  setMovieLinksOnMovieServer(input: SetMovieLinksOnMovieServerInput!): MovieServer!
  setMovieServersOnMoviePart(input: SetMovieServersOnMoviePartInput!): MoviePart!
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

type Query {
  categories(
    """Specify to filter the records returned."""
    filter: CategoryFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [CategorySort!] = []
  ): CategoryConnection!
  category(
    """The id of the record to find."""
    id: Int!
  ): Category
  getJobs: [JobsListResult!]!
  movie(
    """The id of the record to find."""
    id: Int!
  ): Movie
  movies(
    """Specify to filter the records returned."""
    filter: MovieFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [MovieSort!] = []
  ): MovieConnection!
}

input SetMovieLinksOnMovieServerInput {
  """The id of the record."""
  id: Int!

  """The ids of the relations."""
  relationIds: [Int!]!
}

input SetMovieServersOnMoviePartInput {
  """The id of the record."""
  id: Int!

  """The ids of the relations."""
  relationIds: [Int!]!
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

type Subscription {
  createdMovie(input: CreateMovieSubscriptionFilterInput): Movie!
  deletedManyMovies: DeleteManyResponse!
  deletedOneMovie(input: DeleteOneMovieSubscriptionFilterInput): MovieDeleteResponse!
  updatedManyMovies: UpdateManyResponse!
  updatedOneMovie(input: UpdateOneMovieSubscriptionFilterInput): Movie!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateOneMovieSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MovieSubscriptionFilter!
}
